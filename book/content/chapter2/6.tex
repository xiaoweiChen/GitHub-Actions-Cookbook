
每次进行工作流程并在服务器上运行它们可能是一个缓慢的过程,尤其是对于复杂的工作程。在此食谱中,我们将学习如何使用ACT(\url{https://github.com/nektos/act})在本地运行作流程。

\mySubsubsection{2.6.1}{Getting ready}

Act取决于Docker运行工作流程。确保您正在运行Docker。

您可以使用不同的软件包管理器安装ACT(请参阅\url{https://github.com/nektos/act#installationthrough-package-managers})。只需选择适合您的环境的一个并按照说明。

首次运行ACT时,它将要求您选择用于默认的Docker映像。 它将将该信息保存到~/。actrc 有不同的图像。有可用的小图像(节点:16-buster-slim)只能支持Nodejs,仅此而已。大图像大小超过18 GB。请记住这一点。但是,借助当今的磁盘空间和互联网,您将使用大像获得最佳结果。对于当前的工作流程,您应该至少选择中型图像(请参见图2.25):

\myGraphic{0.4}{content/chapter2/images/25.png}{图2.25  ---  在ACT的第一次运行中选择容器图像}

\mySubsubsection{2.6.2}{How to do it…}

在我们当前的存储库中打开命令提示符,并查看新的工作流分支。 ACT使用工作流触发器对工作流进行作用,并且将默认推动。由于我们的工作流程仅具有pull\_request触发器, 此您必须指定。使用-L选项,ACT将在存储库中使用相应的触发器列出所有工作流和作。执行以下命令:

\begin{shell}
$ act pull_request -l
\end{shell}

检查工作流程和工作。要执行干式运行，您可以使用选项-n：

\begin{shell}
$ act pull_request -n
\end{shell}

请注意,工作流程成功完成,因为没有执行工作流的覆盖。要真正执行容器中的工作流程请运行以下命令:

\begin{shell}
$ act pull_request
\end{shell}

工作流将以与服务器上的拉请求中的方式相同的方式执行和失败。结果应该看起来像图2.26：

\myGraphic{0.4}{content/chapter2/images/26.png}{图2.26  ---  Workflow linting失败，与服务器上的错误相同}

不难看出，在将更改推送到服务器之前，能够本地运行您的工作流程是多么强大。然而，根据您的工作流程，结果可能并非 100\% 可靠，并且您可能需要使用一个超过 20GB 的大型 Docker 镜像。

\mySubsubsection{2.6.3}{How it works…}

Act 使用 Docker 容器来本地运行您的工作流程。它从.github/workflows/ 读取您的 GitHub Actions，并确定需要运行的一系列操作。根据工作流程文件中的定义，它使用 Docker API 来拉取或构建必要的镜像，然后基于所定义的依赖关系确定执行路径。一旦确定了执行路径，Act 就会使用 Docker API 根据之前准备好的镜像为每个操作运行容器。环境变量和文件系统都配置为与 GitHub 提供的相匹配。

如果您的工作流程使用 GITHUB\_TOKEN，则需要提供一个个人访问令牌(PAT)；Act 将使用它来与 GitHub 进行通信。确保您提供的 PAT 拥有适当的权限以执行所需的操作。这样可以保证 Act 在处理涉及与 GitHub 交互的任务时不会遇到权限不足的问题。

\begin{shell}
$ act -s GITHUB_TOKEN=[insert personal access token]
\end{shell}

您可以使用 GitHub CLI 的 \verb|gh auth token| 命令自动将令牌从 CLI 传递给 Act:

\begin{shell}
$ act -s GITHUB_TOKEN="$(gh auth token)"
\end{shell}

\mySubsubsection{2.6.4}{There’s more…}

Act 的问题在于，默认 GitHub 托管运行器的镜像非常庞大。为了获得良好的本地性能，不可能将这些运行器上安装的所有工具都包含进来。对于 90\% 的工作流程而言，这也并非必要，因为操作通常在 NodeJS 中运行或自带其容器。然而，特别是在 run 步骤中使用自定义脚本时涉及到命令行工具，这就成了一个问题。

使用 Act 时非常好用的一个功能是为您的工作流作业使用自定义镜像。这意味着，与其依赖 GitHub 托管运行器上的工具，您可以为作业分配自定义 Docker 镜像，例如：

\begin{shell}
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: custom-image:latest
\end{shell}

这种方式下，本地执行和服务器上的执行基本上是一致的。如果您需要长时间维护构建环境，这也是一个很好的选择。要了解更多关于在容器中运行作业的信息，请访问： \url{https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container}。