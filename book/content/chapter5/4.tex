在本示例中，我们将使用环境审批(environment approvals)，在创建仓库之前获取审批。我们还将使用一个 GitHub App 进行身份验证，因为通常在组织范围内创建仓库的操作无法通过 GITHUB\_TOKEN 完成。你必须使用一个 GitHub App 或具有适当权限范围的个人访问令牌(PAT)。

\mySubsubsection{5.4.1}{Getting ready}

确保你已完成前面的示例，并继续在同一个仓库中操作。

\mySubsubsection{5.4.2}{How to do it…}

\begin{enumerate}
\item 
在你的仓库中，进入 Settings(设置) → Environments(环境)，然后点击 New environment(新建环境)。

\item 
将环境命名为 repo-creation，然后点击 Configure environment(配置环境)。

\item 
将自己添加为必填审阅人(Required reviewer)，并且不要允许管理员绕过该规则(参见图 5.7)。

\myGraphic{0.4}{content/chapter5/images/7.png}{图 5.7 --- 配置环境保护规则}

\item 
点击 Save protection rules(保存保护规则)。

\item 
下一步是创建一个应用进行身份验证。我们建议你使用一个组织来尝试本示例 --- 当然你也可以使用个人账户。前往 \url{https://github.com/settings/apps}，然后点击 New GitHub App(新建 GitHub 应用)。

\item 
为其设置一个唯一名称(例如 \{你的用户名\}-repo-creation)，并将 Homepage URL 设置为你的仓库地址。

\item 
在 Repository permissions(仓库权限) 部分，选择以下权限：

\begin{itemize}
\item 
Administration(管理): Read and write(读写)

\item 
Contents(内容): Read and write(读写)

\item 
Issues(议题): Read and write(读写)
\end{itemize}

在 Organization permissions(组织权限) 部分，选择：

\begin{itemize}
\item 
Administration(管理): Read and write(读写)
\end{itemize}

\item 
点击 Save(保存) 应用。在你新创建的应用页面中，点击 Generate a private key(生成私钥)。私钥将会自动下载到你的本地设备。

\item 
从应用的 General(常规) 页面复制 App ID。

\item 
在 GitHub 的应用页面中，选择 Install App 并点击 Install(安装)。选择你的组织或账户，点击 Install，保留默认的 All repositories(所有仓库) 选项，再次点击 Install。

\item 
返回到你的仓库中的 Environments(环境) 设置页面。添加一个新的密钥 PRIVATE\_KEY，内容为你之前下载的私钥文件内容。同时，添加一个 APP\_ID 变量，并填入你的应用的 ID(参见图 5.8)。

\myGraphic{0.4}{content/chapter5/images/8.png}{图 5.8 --- 向环境中添加变量和密钥}

\item 
编辑你的工作流文件，添加一个额外的 create-repo 任务。让该任务依赖于前一个任务(needs: issue-ops)，并为其分配我们之前创建的环境(environment: repo-creation)：

\begin{shell}
create-repo:
  needs: issue-ops
  runs-on: ubuntu-latest
  environment: repo-creation
\end{shell}

\item 
要使用 GitHub 令牌与议题进行交互，请为工作流设置权限：

\begin{shell}
  permissions:
    issues: write
    contents: read
\end{shell}

\item 
我们可以使用在所有步骤中都能访问的全局环境变量。将 REPO\_OWNER 设置为你已安装应用的组织或账户。你也可以将该值保存为环境中的变量。将 REPO\_NAME 设置为前一个任务的输出。USER 和 ISSUE\_NUMBER 则设置为上下文中的值，以便于访问：

\begin{shell}
env:
  REPO_OWNER: ${{ vars.ORGANIZATION }}
  REPO_NAME: ${{ needs.issue-ops.outputs.REPO_NAME }}
  USER: ${{ github.event.issue.user.login }}
  ISSUE_NUMBER: ${{ github.event.issue.number }}
\end{shell}

\item 
要使用应用进行身份验证，我们可以使用 actions/create-github-app-token 这个 Action。为其设置一个 ID，以便后续引用：

\begin{shell}
steps:
  - name: Create app token
    uses: actions/create-github-app-token@v1.6.2
    id: get-workflow-token
    with:
      app-id: ${{ vars.APP_ID }}
      private-key: ${{ secrets.PRIVATE_KEY }}
      owner: ${{ vars.ORGANIZATION }}
\end{shell}

\item 
创建仓库，并将 URL 设为输出参数：

\begin{shell}
- name: Create repository
  id: create-repo
  env:
    GH_TOKEN: ${{ steps.get-workflow-token.outputs.token }}
  run: |
    REPO_URL=$(gh repo create $REPO_OWNER/$REPO_NAME --private --clone)
    echo "repo_url=$REPO_URL" >> "$GITHUB_OUTPUT"
    echo "Repositeory '$REPO_NAME' has been successully created: $REPO_URL"
\end{shell}

\item 
如果操作成功，在议题上发表评论，通知用户仓库已创建：

\begin{shell}
- name: Notify User
  if: ${{ success() }}
  env:
    GH_TOKEN: ${{ github.token }}
    REPO_URL: ${{ steps.create-repo.outputs.repo_url }}
  run: |
    gh issue comment $ISSUE_NUMBER \
      -b "@$USER: Repository '$REPO_OWNER/$REPO_NAME' has been created successfully: $REPO_URL" \
      --repo ${{ github.event.repository.full_name }}
\end{shell}

\item 
如果发生错误，也通过在议题上发表评论通知用户：

\begin{shell}
- name: Handle Exception
  if: ${{ failure() }}
  env:
    GH_TOKEN: ${{ github.token }}
  run: |
    gh issue comment $ISSUE_NUMBER \
      -b "@$USER: Repository '$REPO_OWNER/$REPO_NAME' creation failed. Please contact the administrator."\
      --repo ${{ github.event.repository.full_name }}
\end{shell}

\item 
提交并推送工作流文件，然后创建一个新的 Repository Request 问题。根据你的通知设置，你会收到一条通知，提示你审查该工作流，因为你已被配置为该环境的必填审阅人。该工作流效果如图 5.9 所示：

\myGraphic{0.4}{content/chapter5/images/9.png}{图 5.9 --- 使用环境进行手动工作流审批}

\item 
点击 Review deployments(审查部署),选择相应的环境,然后点击 Approve and deploy(批准并部署)(参见图 5.10)。

\myGraphic{0.4}{content/chapter5/images/10.png}{图 5.10 --- 批准部署到环境}

工作流将会创建仓库，并通过在议题中发表评论的方式通知发起请求的用户(参见图 5.11)。

\myGraphic{0.4}{content/chapter5/images/11.png}{图 5.11 --- 工作流使用议题评论通知用户仓库创建成功}

检查链接是否有效以及仓库是否已正确创建。

\end{enumerate}

\mySubsubsection{5.4.3}{How it works…}

你可以在工作流中将任务分配给特定环境，从而为该环境添加保护规则、特定变量和密钥。

\mySamllsectionNoContent{环境}

环境可以通过 Web UI 或 API 在仓库中创建。使用 API 创建环境的例子如下：

\begin{shell}
curl -L \
  -X PUT \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/environments/<NAME> \
  -d '{"wait_timer":30,"prevent_self_review":false,"reviewers":[{"-type":"User","id":1},{"type":"Team","id":1}],"deployment_branch_policy":{"protected_branches":false,"custom_branch_policies":true}}'
\end{shell}

在大多数情况下，你将通过 Web UI 创建环境，就像我们在本示例中所做的那样。在工作流中，通过名称引用环境：

\begin{shell}
jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
\end{shell}

你可以添加一个额外的 URL，该 URL 将显示在工作流中：

\begin{shell}
environment:
  name: production
  url: https://writeabout.net
\end{shell}

这允许你在工作流中创建动态环境并部署到这些环境中。如果你希望将每个拉取请求部署到一个隔离的环境进行测试，这是非常有用的。

你可以通过不同的保护规则来保护环境：

\begin{itemize}
\item 
必需的审阅者：你可以列出最多六位用户或团队作为必需的审阅者来批准引用该环境的工作流任务。审阅者必须至少对仓库有读取访问权限。只需要一位必需的审阅者批准作业即可继续。

\item 
等待计时器：可以在最初触发作业后暂停工作流一段时间。时间(以分钟为单位)必须是介于 0 到 43,200(30天)之间的整数。你可以使用 API 在这段时间内取消工作流。

\item 
部署分支和标签：使用部署分支和标签限制哪些分支和标签可以部署到环境。环境的部署分支和标签选项包括无限制、仅受保护的分支或选定的分支和标签。在设置中,你可以添加名称模式以针对单个或一组分支或标签 --- 例如 main 或 release/*。将环境连接到分支保护规则非常强大,因为你可以为此设置更多的保护规则 --- 比如强制执行代码所有者或特定环境的部署。
\end{itemize}

环境还具有特定的密钥和变量，允许你在同一个工作流中使用不同的配置。

此外还有 自定义部署规则(Custom Deployment Rules) 来保护你的环境。本书撰写时，该功能仍处于公开测试阶段。自定义部署规则本质上是 GitHub Apps，它允许你编写自己的集成逻辑。这使得 Datadog、Honeycomb 和 ServiceNow 等服务可以为部署提供自动化审批。

要了解更多关于环境的信息，请参阅：\url{https://docs.github.com/en/actions/ deployment/targeting-different-environments/using-environments-fordeployment}。

\mySamllsectionNoContent{身份验证}

通过 GitHub 令牌(GITHUB\_TOKEN)和工作流权限,你可以完成许多操作。但在组织级别进行自动化时,通常你需要使用 PAT(Personal Access Token)或 GitHub App 进行身份验证。GitHub 建议使用 GitHub Apps,因为它们不依赖于某个具体用户。你已经在上一章中学过 GitHub Apps 的相关内容。

要在工作流中使用 GitHub App 进行身份验证,可以使用 actions/create-github-app-token 这个 Action:

\begin{shell}
steps:
  - name: Create app token
    uses: actions/create-github-app-token@v1.6.2
    id: get-workflow-token
    with:
      app-id: ${{ vars.APP_ID }}
      private-key: ${{ secrets.PRIVATE_KEY }}
\end{shell}

它需要你存储在环境变量和密钥中的 App ID 和私钥。生成的令牌可以通过步骤的输出访问：

\begin{shell}
- name: Create repository
  env:
    GH_TOKEN: ${{ steps.get-workflow-token.outputs.token }}
\end{shell}

通过这个 Action，在你的工作流中使用 GitHub Apps 变得非常简单。

\mySubsubsection{5.4.4}{There’s more…}

Issue 是与用户交互的好方式 --- 但你也可能希望将自动化的状态存储在其他地方。你可以选择更新一个 YAML 或 Markdown 文件，或者调用一个外部系统。

不过，你也可以使用 GitHub Projects 来可视化这些 Issue。这样，Issue 就代表了一个自动化对象在其生命周期中的状态。

GitHub Projects 非常灵活，你可以在其中包含来自不同仓库的议题和拉取请求。这也意味着它相对复杂，你需要使用内部 ID 来引用字段。

在修改工作流之前，先对你正在跟踪议题的项目运行以下命令(以我的为例，项目的 ID 是 19，所有者是 wulfland)：

\begin{shell}
$ gh project field-list <ID> --owner <OWNER> --format json | jq
\end{shell}

\begin{shell}
{
    "id": "PVTSSF_lAHOAFCCsc4AZoDtzgQZkEg",
    "name": "Status",
    "type": "ProjectV2SingleSelectField",
    "options": [
      {
        "id": "f75ad846",
        "name": "Request"
      },
      {
        "id": "e05aa0a3",
        "name": "Repository Created"
      },
      {
        "id": "98236657",
        "name": "Deleted"
      }
    ]
  },
\end{shell}

将这些内部 ID 作为变量存储在环境中，如图 5.12 所示。

\myGraphic{0.4}{content/chapter5/images/12.png}{图 5.12 --- 使用内部项目 ID 来引用字段和选项}

在工作流中添加一个额外的步骤，并设置以下环境变量：

\begin{shell}
- name: Update Project
  if: ${{ success() }}
  env:
    GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
    REPO_URL: ${{ steps.create-repo.outputs.repo_url }}
    PROJECTNUMBER: ${{ vars.PROJECT_ID }}
    PROJECTOWNER: ${{ vars.PROJECT_OWNER}}
\end{shell}

首先，你需要获取项目的内部 ID，因为后续命令中需要用到它。普通的项目编号(数字)并不能在所有命令中使用：

\begin{shell}
run: |
  project_id=$(gh project list --owner "$PROJECTOWNER" --format json | jq -r '.projects[] | select(.number=='$PROJECTNUMBER') | .id')
\end{shell}

接下来，获取该议题的内部 ID：

\begin{shell}
issue_id=$(gh project item-list $PROJECTNUMBER \
  --owner "$PROJECTOWNER" \
  --format json \
  | jq -r '.items[] \
  | select(.content.number=='$ISSUE_NUMBER') | .id')
\end{shell}

现在，你可以根据工作流中的值来更新字段。将该项目的状态设置为“Repository Created”选项：

\begin{shell}
gh project item-edit \
  --id $issue_id \
  --field-id ${{ vars.RPOJECT_STATUS_FIELD_ID }} \
  --single-select-option-id ${{ vars.PROJECT_REPO_CREATED_OPTION_ID }} \
  --project-id $project_id
\end{shell}

将仓库的 URL 设置为“URL”字段的值：

\begin{shell}
gh project item-edit \
  --id $issue_id \
  --field-id ${{ vars.PROJECT_URL_FIELD_ID }} \
  --text $REPO_URL \
  --project-id $project_id
\end{shell}

最后，将“创建日期”字段设置为当前日期：

\begin{shell}
gh project item-edit --id $issue_id \
  --field-id ${{ vars.PROJECT_CREATED_FIELD_ID }} \
  --date $(date +%Y-%m-%d) \
  --project-id $project_id
\end{shell}

现在你可以在 GitHub Projects 中跟踪你的仓库请求状态(图 5.13)。

\myGraphic{0.4}{content/chapter5/images/13.png}{图 5.13 --- 在 GitHub Projects 中跟踪 IssueOps 的状态}

每个议题的卡片上也会显示这些元数据(见图 5.14)。

\myGraphic{0.4}{content/chapter5/images/14.png}{图 5.14 --- GitHub Issues 中的 GitHub Projects 卡片}

GitHub Projects 非常适合用于跟踪议题状态，但使用 GraphQL API 或 CLI 对其进行自动化操作并不容易。然而，如果你希望在 IssueOps 方面做更多事情，这绝对是一个值得投入的方向。































